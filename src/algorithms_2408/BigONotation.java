package algorithms_2408;

public class BigONotation {
    //Big O - верхняя оценка алгоритма,оценивает наихудший случай временной сложности, функция, описывающая рост количества операций выполняемых алгоритмом в  зависимости от входных данных.
    //O(1) - порядок роста константный, означает, что вычислительная сложность не зависит от размера входных данных
    public int getSize(int[] arr) {
        return arr.length;
    }
    //O(n) - порядок роста линейный, сложность алгоритма линейно растет с увеличением входного массива
    // например линейный алгоритм обрабатывает один элемент за одну секунду, то сто элементов за 100 секунд
    // O(n) - означает, что алгоритм потребует не более n шагов

    public long getSum(int[] arr) {
        long sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += i;
        }
        return sum;
    }
    public void printArr(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }

    // O(log n) - порядок роста логарифмический, время выполнения алгоритма растет логарифмически с увеличением размера входного массива
    // "деление пополам", пример: бинарный поиск
    // чаще всего используется с циклом while
    /* while(n <= 1) {
          n = n/2

     */
    /* int i = n;
    while (i > 0) {
        i /= 2
    }
    // O(n log n) - порядок роста линейно-логарифмический
    //"разделяй и властвуй", пример: сортировка слиянием и быстрая сортировка
    for (int i = 0; i < n; i++) {
                for (int j = 1; j < n; j *= 2) { // или j /= 2
                //some code
                }
     */

    //O(n^2) - порядок роста квадратичный, зависит от квадрата размера входного массива
    /* Квадратичная сложность - повод задуматься и переписать алгоритм
    Массив из 100 элементов потребует 10000 операций
    Пример : сортировка пузырьком
    Обычно применяется в двойных for - двумерный массивы
     */
    public void printArray(int[] arr){
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length - 1; j++) {
                System.out.println(i + j);
            }
        }
    }

    // O(n!) - порядок роста факториальный
    /* очень медленный алгоритм
    данный алгоритм из класса NP - задача с ответом да или нет
    пример : массив с перестановкой элементов, мы ищем все возможные перестановки в массиве
     */

    // O(n^3)
    public void printArrays(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {
                for (int k = 0; k < arr.length; k++) {
                    System.out.println(i + j + k);

                }

            }

        }

    }
    /* При измерении сложности алгоритмов и структур данных мы обычно говорим о двух вещах: количество операций,
    требуемых для завершения работы,(вычислительная сложность), и обьем ресурсов, в частности, памяти,
    который необходим алгоритму (пространственная сложность)
    Алгоритм, который выполняется в десять раз быстрее, но использует в десять раз больше места, может вполне подходить для серверной
    машины с большим обьемом памяти. Но на встроеных системах , где количество памяти ограничено,
    такой алгоритм использовать нельзя.
    Скорость алгоритма мы измеряем не в секундах, а в приросте количества операций
    Определяем насколько быстро возрастает время работы алгоритма в зависимости от увеличения обьема входящих данных
    Время работы алгоритма выражается при помощи нотации большого О
    Алгоритм со скоростью О(log n) быстрее чем со скоростью O(n), но он становится
    намного быстрее по мере увеличения списка элементов
     */

    // Почему игнорируются константы в асимптотическом анализе? - их влияние при огромных размерах данных - минимальны


}
